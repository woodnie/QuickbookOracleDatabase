#### 1.Introduction {#1-introduction}

Architecture

Oracle server 包含：Oracle instance and Oracle database

1.Oracle 内存结构

与Oracle 实例关联的基本内存结构包括：

  1)系统全局区(SGA)：由所有服务器进程和后台进程共享

  2)程序全局区(PGA)：专用于每一个服务器进程或后台进程。每一个进程使用一个PGA

1.1 SGA 是包含实例的数据和控制信息的内存区。SGA 包含以下数据结构：

1.2 PGA

     -排序区（sort area）:用于处理SQL语句所需的排序。

     -游标状态区（cursor state）:用于指示会话当前使用的SQL语句的处理状态。

     -会话信息区（session information）：包含了会话的用户权限和优化统计信息。

     -堆栈区（stack space）：包括了其他的会话变量

如果是共享服务器进程或多线程的配置，以上这些结构除了堆栈区外大部分都将存在于SGA中。如果有lager pool,它们就会被存在于lager pool中，否则它们就会被存在于共享池中。

2.Oracle进程结构

  1) 用户进程：在数据库用户请求连接到Oracle 服务器时启动

  2) 服务器进程：可以连接到Oracle 实例，它在用户建立会话时启动

  3) 后台进程：在启动Oracle 实例时启动

3.Oracle数据库结构（存储结构）

物理数据库结构:

1.数据文件，OS块

构成Oracle 数据库的文件可分为以下几类：

1\. 控制文件：/pm/q/d/controln.ctl

2\. 重做日志文件：/pm/q/d/redon.log

3\. 数据文件：/pm/q/d/tn.dbf

逻辑结构：段、区和块

1\. 方案是数据库用户拥有的数据库对象的集合。方案对象是直接引用数据库数据的逻辑结构。方案对象包括表、视图、序列、存储过程、同义词、索引、集群和数据库链接等结构。一般而言，方案对象包括应用程序在数据库中创建的任何内容。

数据库对象（如表和索引）以段形式存储在表空间中。

2\. 段:每个段都包含一个或多个区。段是为特定逻辑结构分配的区集。

    2.1.数据段：每个非集群、非索引的组织表都有一个数据段。该表的所有数据都存储在表数据段的区中。对于分区表，每个分区都有一个数据段。

         每个集群都有一个数据段。集群中每个表的数据都存储在集群的数据段中。

    2.2.索引段：每个索引都有一个索引段，用于存储索引的所有数据。对于已分区索引，每个分区都有一个索引段。

    2.3.还原段：数据库管理员会创建一个UNDO 表空间，用于临时存储还原信息。

         还原段中的信息用于生成一致读取信息，在数据库恢复过程中，还可用于回退用户的未提交事务。

    2.4.临时段：当SQL 语句需要一个临时工作区来完成执行时，Oracle 数据库会创建临时段。执行完语句后，临时段的区会返回到实例，以供将来使用。

3\. 区是特定数目的相邻数据块（在一次分配中获取的），用于存储特定类型的信息。每个区只能存在于一个数据文件中。

4\. Oracle 数据库的数据以最细的粒度级存储在数据块中。一个数据块对应于磁盘上特定字节数的物理数据库空间。每个表空间的数据块大小是在创建表空间时指定的。数据库可以使用和分配Oracle 数据块中的空闲数据库空间。数据块是数据库中最小的I/O 单元。大小2-32K。 由OS磁盘块儿构成。

请为每个用户指定一个默认临时表空间，或指定一个在数据库级别使用的默认临时表空间。Oracle 数据库可动态分配空间。如果段的现有区已满，则会添加更多的区。

由于区是按需分配的，因此，段的区在磁盘上不一定是相邻的。

2.物理结构(OS块):

数据文件（一一对应区）

Oracle Instance

**Oracle instance**

**Oracle isntance** **包含：** **1.SGA** **：系统全局区，即一部分共享内存区** ~~~~~~~~~Oracle 利用区组（ granule ）来滚利 SGA 的大小。 ~~~~~~~~~~ 如果 SGA 小于 128M ， granule 即为 4M ；如果 SGA 大于等于 128M ， granule 即为 16M 。 指定 SGA 的最大值。 指定特定缓冲区大小 :SQLsystem set~~ 查看 SGA 值： SQLparameter;~~~~~~~~~~~~~~~~~~~sga;~~~~~~~~~~~~~~~~~~~~name,values from v$parameter where name=&amp;apos;SGA_MAX_SIZE&amp;apos;;~~~~~~~~~ ~~~~~1.1 数据库缓冲区高速缓存（ database buffer cache ）：缓存从数据库检索的数据块。 ~~~~~~~~~~ 当用户发出 SQL select 语句时运行到提取数据阶段时，服务器进程首先搜索 database buffer cache ，如果找到了就直接使用而不进行磁盘操作；如果没找到就将进行磁盘操作把数据文件中的数据读入到 database buffer cahce 中。 ~~~~~~~~~~ 缓冲区高速缓存中的缓冲区可能处于以下四种状态之一： ~~~~ ~~~~~~~ 1.1.1\. **已连接** ：可防止多个会话同时对同一数据块执行写操作。此时，其它会话正等待访问该块。 ~~~~~~~~~~~ **干净** ：缓冲区现已解除连接，如果没有再次引用当前内容（数据块），则可以考虑立即腾出该缓冲区。 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 此时，不是缓冲区的内容已与磁盘中存储的数据块内容同步，就是缓冲区中包含块的一致读取 (CR) 快照。 ~~~~~~~~~~~1.1.3\. **空闲或未使用** ：实例刚刚启动，缓冲区为空。此状态与 &quot; 干净 &quot; 状态非常相似，不同之处在于缓冲区尚未使用。 ~~~~~~~~~~~~ **脏** ：缓冲区不再处于已连接状态，但是内容（数据块）已更改， DBWn 必须先将内容刷新到磁盘，才能腾出缓冲区。 --------------------------------------&gt; 动态调整 database buffer cache 大小 :&gt;8i 以前版本，修改参数文件中以下值： &gt;DB_BLOCK_SIZE~~~~~~~~~# 缓冲区块儿的大小，创建数据库时设定的，如果更改需重启。 &gt;DB_BLOCK_BUFFERS~# 缓冲区块儿的个数。 &gt;9i 以后版本，修改参数文件中以下值： &gt;DB_CACHE_SIZA&gt;SQLalter system db_cache_size = 48M;&gt; 动态参数无需重启，即使生效。 --------------------------------------~ ~~~~~1.2.~ 重做日志缓冲区（ redo log buffer ）：高速缓存重做信息直到可以将其写入磁盘中存储的物理重做日志文件（用于实例恢复）。 ~~~~~1.3\. 共享池 (share pool) ：缓存可在用户间共享的各个结构。 ~~~~~~~~~~~~-library cache~ 库高速缓存：分为共享 SQL 区和共享 PL/SQL 区，存放 SQL select 语句正文和编译后的代码。 ~~~~~~~~~~~~-data dictionart cache 数据字典高速缓存：存放执行 SQL select 语句时使用的数据文件，表，索引，列，用户和其他数据对象的定义和权限信息。 --------------------------------------------------------------------Oracle 没有给出直接设置 library cache/data dictionary cache 的直接方法，只能通过修改参数文件中 SHARED_POPL_SIZE 的大小来间接的设置： --SQLsystem set SHARED_POOL_SIZE = 32M;-- 需重启 Oracle 数据库才能生效。 ------------------------------------------------------------------~~~~~1.4\. 大型池 (lager pool) ：是一个可选区域，可为某些大型进程（如 Oracle 备份和恢复操作、 I/O 服务器进程）提供大量内存分配。 ~~~~~1.5\. Java 池 (java pool) ：用于 Java 虚拟机 (JVM) 中特定会话的所有 Java 代码和数据。 ~-------------------------------- 使用动态参数： LAGRE_POOL_SIZE 调整 lager pool 的大小 使用动态参数： JAVA_POOL_SIZE~~~~ 调整 JAVA pool 的大小 SQLsystem set /--------------------------------~~~~~~1.6\. Streams 池 (Streams pool) ：由 Oracle Streams 使用。 --------------------------------Oracle 9i 及以后版本提供获得缓存信息统计工具： V$db_cache_advice~~~~~~~~~~~~~~~~~~~~~~~~~~~#database buffer cache 统计信息 V$SGA_DYNAMIC_COMPONENTS~~~~# 获得各种 buffer 的信息 -------------------------------- **2.Oracle （后台）进程** 常见的后台进程： 2.1\. 系统监视器 (SMON) ：出现故障后，在启动实例时执行崩溃恢复任务 2.2\. 进程监视器 (PMON) ：用户进程失败时执行进程清理任务 2.3\. 数据库写进程 (DBWn) ：将修改后的块从数据库缓冲区高速缓存写入磁盘中的数据文件 2.4\. 检查点 (CKPT) ：通过更新数据库的所有数据文件和控制文件指出最新的检查点 2.5\. 日志写进程 (LGWR) ：将重做日志条目写入磁盘 以上 5 个后台进程是必须得。 2.6\. 归档进程 (ARCn) ：发生日志切换时将重做日志文件复制到归档存储器（非必须的后台进程）

启动实例后， Oracle 软件会将实例与特定的数据库关联。这个过程称为装载数据库。接下来可以打开数据库，以便授权用户访问数据库。在同一台计算机上可以并发执行多个实例，每一个实例只访问自己的物理数据库。

每个实例只能操作一个数据库。在 oracle 集群中一个数据库可以同时被几个实例操作。

Oracle database

  1\. 控制文件(contro files)：包含有关数据库本身的数据（即物理数据库的结构信息）。

      这些文件对数据库而言至关重要。没有这些文件，就无法打开用于访问数据库数据的数据文件。一般为3份，最多8份，最少2份，互为镜像。

  2\. 数据文件(data files)：包含数据库中的用户数据或应用程序数据。一般3个。

  3\. 联机重做日志文件(redo log files)：可用来实现数据库实例恢复。

      如果数据库已崩溃但未丢失任何数据文件，那么使用这些文件中的信息可以通过实例恢复数据库。一般3个。

要成功运行数据库，以下附加文件也是非常重要的：

  4\. 参数文件(Parameter files)：用于定义启动实例时如何配置实例。

  5\. 口令文件(Password files)：允许用户远程连接到数据库并执行管理任务。

  6\. 备份文件：用于恢复数据库。当因介质故障或用户错误而损坏或删除了原始文件时，通常需要还原备份文件。

  7\. 归档日志文件(Archive log files)：包含实例生成的数据更改（重做）的实时历史记录。

      使用这些文件和数据库备份可以恢复丢失的数据文件。也就是说，使用归档日志可以恢复还原的数据文件。  

  8\. 跟踪文件(Trace files)：每个服务器和后台进程都可以对关联的跟踪文件执行写操作。

      如果在进程中检测到内部错误，进程就会将关于错误的信息转储到进程的跟踪文件中。

      写入到跟踪文件中的某些信息专门供数据库管理员使用，另一些信息则供Oracle 支持服务部门使用。

  9\. 预警日志文件(Alert log files)：是特殊的跟踪文件，又称为预警日志。数据库预警日志是按时间顺序列出的消息日志和错误日志。Oracle 建议您查看这些文件。