#### 7.Managing Schema {#7-managing-schema}

Schema

Part1.Schema

**A.** **方案** 是指由特定用户拥有的数据库对象的集合。对于生产数据库而言，这个用户代表的通常不是一个人，而是一个应用程序。方案与拥有该方案的用户同名。方案对象是指直接引用数据库数据的逻辑结构。方案对象包含表、视图和索引等多种结构。

创建数据库时，系统会创建多个方案。 以下是两个重要方案： 1\. 方案：包含数据字典，这在 &quot; 管理用户安全性 &quot; 一课有所介绍。 2\. 方案：包含存储管理信息的附加表和视图。 &quot; 管理用户安全性 &quot; 一课对此进行了介绍。 以下是几个示例方案： 1\. HR ： &quot; 人力资源 &quot; 方案是一个用于介绍基本主题的简单方案。此方案经过扩展后可支持 Oracle Internet Directory 演示。 2\. ： &quot; 订单录入 &quot; 方案是一个中等复杂程度的方案。 OE 方案中提供了多种数据类型。 OC （联机目录）子方案是内置于 OE 方案中的对象关系数据库对象的集合。 3\. PM ： &quot; 产品媒体 &quot; 方案专用于多媒体数据类型。 4\. ： &quot; 排队发运 &quot; 方案包含一组用于演示 Oracle Advanced Queuing 功能的方案。 5\. ： &quot; 销售历史记录 &quot; 方案用于演示大量数据。这个方案经过扩展可支持高级分析处理。

Schema Objects

命名数据库对象 1.~ 名称长度必须为 1 至 30 个字节，但以下情况除外： - 数据库名称为 8 个字节。 - 数据库链接名最长可为 128 个字节。 2.~ 不带引号的名称不能采用 Oracle 保留字。 3.~ 不带引号的名称必须以数据库字符集中的字母字符开头。 4.~ 不建议使用带引号的名称。 注： 命名数据库中的对象时，可以将名称括在双引号 (&quot;&quot;) 中。使用这种方式，您可以违反幻灯片中提到的一些命名规则。。但是，我们不建议这样做，因为如果采用这种方式命名对象，那么引用时名称永远都要带着引号。 不带引号的名称会以大写形式存储且不区分大小写。处理 SQL 语句时，不带引号的名称会全部转换为大写。 不带引号的标识符只能包含数据库字符集中的字母数字字符，以及下划线 (_) 、美元符号 ($) 和磅符号 (#) 。数据库链接还可包含句点 (.) 和 &quot;at&quot; 符号 (@) 。强烈反对在不带引号的标识符中使用 $ 和 # 。 带引号的标识符可以包含任意字符、标点符号和空格。但是，带引号与不带引号的标识符都不能包含双引号。

以下是 Oracle 数据库中的内置数据类型： 1.CHAR(size [BYTE|CHAR]) ： size 个字节或字符的固定长度字符数据。最大大小为 2,000 个字节或字符，默认大小及最小大小均为 1 个字节。 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~- BYTE 表示列采用字节长度语义。 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~- CHAR 表示列采用字符语义。 2.VARCHAR2(size [BYTE|CHAR]) ：最大长度为 size 个字节或字符的可变长度字符串。最大大小为 4,000 个字节。必须指定 VARCHAR2 的大小。 3\. ：在公元前 4712 年 1 月 1 日至公元 9999 年 12 月 31 日之间的有效日期。它还存储以下时间：小时、分钟和秒。 4\. NUMBER(p,s) ：精度为 p 且小数位数为 s 的数字。精度可介于 1 与 38 之间。小数位数可介于 -84 与 127 之间。 5\. ： 32 位浮点数。这种数据类型需要 5 个字节（包括长度字节）。 6\. ： 64 位浮点数。这种数据类型需要 9 个字节。 7\. ：美国国家标准协会 (ANSI) 数据类型。 FLOAT 数据类型是二进制精度为 p 的浮点数。这种数据类型的默认精度为二进制数 126 或十进制数 38 。 8\. ：等效于 NUMBER(p,0) 。 9\. ： NCHAR 数据类型是仅使用 Unicode 的数据类型。创建包含 NCHAR 列的表时，请以字符为单位定义列长度。创建数据库时，请定义国家字符集。列的最大长度根据国家字符集定义来确定。 NCHAR 数据类型的宽度规范是指字符数。允许的最大列大小为 2,000 个字节。如果插入值小于列长度，为了完全达到列长度， Oracle 数据库会使用空格填充该值。不能将 CHAR 值插入到 NCHAR 列中，也不能将 NCHAR 值插入到 CHAR 列中。 10.~ NVARCHAR2 (size [BYTE|CHAR]) ： NVARCHAR2 数据类型是仅使用 Unicode 的数据类型。它与 NCHAR 相似，不同之处在于，它的最大长度为 4,000 字节且不能使用空格填充。 11\. ：可变长度最大为 2 GB 或 231 -1 个字节的字符数据。 LONG 数据类型已弃用；请改用大对象 (LOB) 数据类型。 12.RAW ：可变长度最大为 2 GB 的原始二进制数据。 13\. ：长度为 size 个字节的原始二进制数据。最大大小为 2,000 个字节。必须指定 RAW 值的大小。 14\. ： Base 64 字符串，表示某一行在数据库中的唯一地址。这种数据类型主要用于 ROWID 伪列返回的值。 15\. ： Base 64 字符串，表示某一行在索引表中的逻辑地址。可选大小为 UROWID 类型的列的大小。最大大小及默认大小均为 4,000 个字节。 16\. ：二进制大对象。 17\. ：字符大对象，包含单字节字符或多字节字符。支持固定宽度字符集和可变宽度字符集，这两种字符集都使用 CHAR 数据库字符集。 18\. ：字符大对象，包含 Unicode 字符。支持固定宽度字符集和可变宽度字符集，这两种字符集都使用 NCHAR 数据库字符集。这种数据类型用于存储国家字符集数据。 注：所有 LOB 数据类型（ BLOB 、 CLOB 和 NCLOB ）的最大大小为： (4 GB - 1) * (CHUNK 值 ) 。 CHUNK 是定义 LOB 时可设置的可选属性。 CHUNK 指定了要为 LOB 操作分配的字节数。如果字节大小不是数据库块大小的倍数，那么数据库会将字节大小舍入为下一个倍数。例如，如果数据库块大小为 2,048 ， CHUNK 大小为 2,050 ，数据库会分配 4,096 字节（ 2 个块）。最大值为 32,768 (32 KB) ，这是允许的 Oracle 数据库块最大大小。默认的 CHUNK 大小为 1 个 Oracle 数据库块。 19\. ： BFILE 数据类型包含到存储在数据库之外的大型二进制文件的定位符。通过这种数据类型可以字节流 I/O 方式访问驻留在数据库服务器上的外部 LOB 。最大大小为 4 GB 。 20\. ：使用这种数据类型可指定日期中的年、月和日，以及时间中的小时、分钟和秒。其中 fractional_seconds_precision 是秒小数部分的位数。可接受值为 0 至 9 。默认值为 6 。

Data Integrity

Part2.Data Integrity 数据完整性

**列完整性约束条件** **:** 1.NULL （非空）：默认情况下，表中的所有列均允许空值。 Null 指没有值。 NOTNULL 约束条件要求表列必须包含非空值。 例如，可以定义 NOT NULL 约束条件要求在 EMPLOYEES 表的每一行的 LAST_NAME 列中输入值。 2.Key （唯一键）： UNIQUE 键完整性约束条件要求一列或一组列（键）中的每个值必须唯一，即在指定的列或一组列中，表任意两行的值均不重复。 例如，如果要禁止每行显示重复的部门名称，请对 DEPARTMENTS 表的 DEPARTMENT_NAME 列定义 UNIQUE 键约束条件。除了特殊情况，这个约束条件与唯一索引一起强制使用。 3.KEY （主键）：数据库中的每个表最多可包含一个 PRIMARY KEY 约束条件。在这个约束条件的限制下，单个列或一组列中的值就构成了行的唯一标识符。事实上，每行的名称均由其主键值确定。 - 在指定列或一组列中，表的任意两行不出现重复值。 - 主键列不允许为空。也就是说，每行的主键列必须有一个值。 4\. 引用完整性约束条件：关系数据库中的各个表通过公用列相互关联，因此必须维护用于管理列关系的规则。引用完整性规则可确保这些关系能够持续下去。对于每个表行，引用完整性约束条件要求外键中的值必须与父键中的值匹配。 5\. 检查约束条件：单个列或一组列的 CHECK 完整性约束条件要求为每个表行指定的条件必须为真或未知。如果数据操纵语言 (DML) 语句对 CHECK 约束条件的求值为假，则会回退语句。

**违反约束条件的示例包括：** 1.~ 唯一性：插入重复的主键值 2.~ 引用完整性：删除引用完整性约束条件中的子行的父行 3.~ 检查：更新后的列值超出了检查约束条件的范围

**约束条件状态** 1.NOVALIDATE ：不检查新数据和现有数据，因此这些数据可能不符合约束条件。当数据来自验证过的源，而且表是只读表时，通常会使用此状态，这样就不会在表中输入新数据。 2.VALIDATE ：如果约束条件处于此状态，则不允许对受约束的列进行任何修改，因为在验证现有数据后又允许将未经检查的数据输入表中，会出现不一致的情况。在必须验证现有数据，但不希望修改数据，而且考虑到性能又不需要另外创建索引时，通常会使用此状态。 3.NOVALIDATE ：新数据符合约束条件，但现有数据处于未知状态。在可以更正现有约束条件违规情况，同时又不允许将新的违规数据输入到系统中时，常常会使用此状态。 4.VALIDATE ：新数据与现有数据均符合约束条件。这是约束条件的典型状态和默认状态。

**约束条件检查** **非延迟约束条件：** 又称即时约束条件，是在每个 DML 语句结束时强制执行的。违反约束条件会导致回退语句。如果约束条件导致 delete cascade 等操作，则认为该操作是导致执行此操作的语句的一部分。定义为 &quot; 非延迟 &quot; 的约束条件不能更改为延迟约束条件。 **延迟约束条件：** 是提交事务处理时才检查的约束条件。如果在提交时检测到任何违反约束条件的情况，则会回退整个事务处理。当同时输入外键关系中的父行和子行（如在订单录入系统中，需要同时录入订单及订单项）时，这些约束条件非常有用。

使用 SQL 创建约束条件：示例 a. 执行此语句后，需要对 COUNTRIES 表执行插入或更新操作，才能生成唯一的 COUNTRY_NAME 值。但是，有可能在发出此语句后，表中已存在非唯一的 COUNTRY_NAME 值。 NOVALIDATE 关键字指示应忽略这些值。仅新行受到约束条件的约束。 SQL&gt; ALTER TABLE countries ADD (UNIQUE(country_name) ENABLE NOVALIDATE);b. 使用此语句可向雇员表添加主键。约束条件名称为 PK ，主键为 EMPLOYEE_ID 列。 SQL&gt;ALTER TABLE employees ADD CONSTRAINT pk PRIMARY KEY (employee_id)c. 此语句用于在创建表时定义约束条件，而不是以后使用 ALTER TABLE 语句进行定义。 RI 约束条件强制使 FK 列中的值必须存在于 T1 表的主键列中。 CK1 约束条件强制使 PK 和 C1 列大于零。 SQL&gt; CREATE TABLE t1 (pk NUMBER PRIMARY KEY, fk NUMBER, c1 NUMBER,SQL&gt; c2 NUMBER,SQL&gt; CONSTRAINT ri FOREIGN KEY (fk) REFERENCES t1, CONSTRAINTSQL&gt; ck1 CHECK (pk &gt; 0 and c1 &gt; 0));

----------------------------------------------------------------------------- 高水位线（ High-warter mark, HWM ）

在 Oracle 数据的存储中，可以把存储空间想象为一个水库，数据想象为水库中的水。水库中的水的位置有一条线叫做水位线，在 Oracle 中，这条线被称为高水位线（ High-warter mark, HWM ）。在数据库表刚建立的时候，由于没有任何数据，所以这个时候水位线是空的，也就是说 HWM 为最低值。当插入了数据以后，高水位线就会上涨，但是这里也有一个特性，就是如果你采用 delete 语句删除数据的话，数据虽然被删除了，但是高水位线却没有降低，还是你刚才删除数据以前那么高的水位。也就是说，这条高水位线在日常的增删操作中只会上涨，不会下跌。 下面我们来谈一下 Oracle 中 Select 语句的特性。 Select 语句会对表中的数据进行一次扫描，但是究竟扫描多少数据存储块呢，这个并不是说数据库中有多少数据， Oracle 就扫描这么大的数据块，而是 Oracle 会扫描高水位线以下的数据块。现在来想象一下，如果刚才是一张刚刚建立的空表，你进行了一次 Select 操作，那么由于高水位线 HWM 在最低的 0 位置上，所以没有数据块需要被扫描，扫描时间会极短。而如果这个时候你首先插入了一千万条数据，然后再用 delete 语句删除这一千万条数据。由于插入了一千万条数据，所以这个时候的高水位线就在一千万条数据这里。后来删除这一千万条数据的时候，由于 delete 语句不影响高水位线，所以高水位线依然在一千万条数据这里。这个时候再一次用 select 语句进行扫描，虽然这个时候表中没有数据，但是由于扫描是按照高水位线来的，所以需要把一千万条数据的存储空间都要扫描一次，也就是说这次扫描所需要的时间和扫描一千万条数据所需要的时间是一样多的。所以有时候有人总是经常说，怎么我的表中没有几条数据，但是还是这么慢呢，这个时候其实奥秘就是这里的高水位线了。 那有没有办法让高水位线下降呢，其实有一种比较简单的方法，那就是采用 TRUNCATE 语句进行删除数据。采用 TRUNCATE 语句删除一个表的数据的时候，类似于重新建立了表，不仅把数据都删除了，还把 HWM 给清空恢复为 0 。所以如果需要把表清空，在有可能利用 TRUNCATE 语句来删除数据的时候就利用 TRUNCATE 语句来删除表，特别是那种数据量有可能很大的临时存储表。 在手动段空间管理（ Manual Segment Space Management ）中，段中只有一个 HWM ，但是在 Oracle9iRelease1 才添加的自动段空间管理（ Automatic Segment Space Management ）中，又有了一个低 HWM 的概念出来。为什么有了 HWM 还又有一个低 HWM 呢，这个是因为自动段空间管理的特性造成的。在手段段空间管理中，当数据插入以后，如果是插入到新的数据块中，数据块就会被自动格式化等待数据访问。而在自动段空间管理中，数据插入到新的数据块以后，数据块并没有被格式化，而是在第一次在第一次访问这个数据块的时候才格式化这个块。所以我们又需要一条水位线，用来标示已经被格式化的块。这条水位线就叫做低 HWM 。一般来说，低 HWM 肯定是低于等于 HWM 的。

---------------------------------------

Indexes

**Part3.INDEX** **索引** 索引是与表关联的可选结构。创建索引可提高更新和检索数据的性能。 Oracle 索引提供了到数据行的直接访问路径。 可以对表的一个或多个列创建索引。创建索引后， Oracle 服务器会自动维护和使用索引。表数据的更新（如添加新行、更新行或删除行）会自动传播到所有相关的索引，这些对用户来说是完全透明的。

B 树索引：采用二进制树的形式，它是默认的索引类型。 位图索引：每个建立索引的独特值都有一个位图，每一位的位置都表示一行，其中可能包含（也可能不包含）索引值。对于低基数列而言，这是最佳结构。

索引选项 1.~ 唯一索引可确保每个索引值是唯一的。 2.~ 索引可按升序或降序存储其键值。 3.~ 反向键索引以反向顺序存储其键值字节。 4.~ 组合索引是基于多列的索引。 5.~ 基于函数的索引是以函数返回值为基础的索引。 6.~ 在压缩的索引中重复的键值已被删除。

CREATE INDEX my_index ON employees(last_name, first_name);

View

Part4.View

视图是一个或多个表中或其它视图中的数据的自定义表示方式。由于视图可隐藏极其复杂的条件、联接，以及其它复杂表达式和SQL 构造，所以可认为视图是存储的查询。实际上，视图并不包含数据，它们从所基于的表中获取数据。这些表称为视图的基表。

Sequences

Part5.Sequences

Temp Tables

Part6.Temp Tables