#### 5.Storage Structures {#5-storage-structures}

OS blocks

Blocks

**数据库块的结构**

~

Oracle 数据块包含： 1\. 块头：块头包含段类型（如表或索引）、数据块地址、表目录、行目录和事务处理插槽。每个插槽的大小为 23 字节，修改块中的行时会使用这些插槽。块头按从上向下的方向扩展。 2\. 行数据：这是块中行的实际数据。行数据空间按从下向上的方向扩展。 3\. 空闲空间：空闲空间位于块的中间。这样可以根据需要扩展头和行数据空间。插入了一些新行之后，或者使用较大值更新了现有行的某些列之后，行数据就会占用空闲空间。如果行目录需要更多的行条目，或者需要的事务处理插槽数多于最初配置的数目，就会出现头扩展。最初，块中的空闲空间是相邻的。但是，删除和更新操作可能会导致在块空闲空间中产生碎片。必要时 Oracle 服务器会接合块中的空闲空间。

Extents

Extents 区--Data file

Segments

Segments 段

Tablespaces

**Tablespaces**

**Oracle 数据库在逻辑上将数据存储在表空间中，在物理上将数据存储在数据文件中。** 1.~ 表空间： - 只能属于一个数据库 - 包括一个或多个数据文件 - 可进一步划分为逻辑存储单元 - 是存储方案对象数据的资料档案库 2.~ 数据文件： - 只能属于一个表空间和一个数据库 - 是构成表空间的基础文件

数据库、表空间和数据文件彼此密切相关，但也存在不可忽视的差异： 1\. 数据库包括一个或多个称为表空间的逻辑存储单元，这些表空间可以作为一个整体存储数据库的所有数据。 2\. Oracle 数据库中的每个表空间都包括一个或多个称为数据文件的文件，这些数据文件具有与运行 Oracle 软件的操作系统一致的物理结构。 3.~ 数据库的数据作为一个整体存储在构成数据库各个表空间的数据文件中。例如，最简单的 Oracle 数据库包括两个表空间（ SYSTEM 和 SYSAUX 表空间，这两个表空间是必须存在的），每个表空间包含一个数据文件。另一个数据库可能包括三个表空间，每个表空间包含两个数据文件（共有六个数据文件）。一个数据库最多可以包含 65,534 个数据文件。

**预配置数据库中的表空间** 1\. SYSTEM ： Oracle 服务器使用 SYSTEM 表空间管理数据库。包含在这个表空间中的数据字典和表包含关于数据库的管理信息。以上信息均包含在 SYS 方案中，只有 SYS 用户或者拥有所需权限的其它管理用户才能访问这些信息。 2\. ：这是 SYSTEM 表空间的辅助表空间。在 Oracle 数据库早期版本中使用 SYSTEM 表空间或自己表空间的某些组件和产品，现在改为使用 SYSAUX 表空间。每个 Oracle Database 10g 或更高版本都必须拥有 SYSAUX 表空间。 3.TEMP ：如果执行的 SQL 语句需要创建临时段（如大规模排序或创建索引），则可以使用临时表空间。如同为每个用户分配默认的表空间以存储创建的数据对象一样，还会向每个用户分配临时表空间。除非另行指定，否则最佳方案是为数据库定义一个默认临时表空间，会为所有新建用户分配此表空间。在预配置数据库中， TEMP 表空间被指定为默认临时表空间。这意味着，如果在创建用户帐户时未指定临时表空间， Oracle 数据库会将此表空间分配给用户作为临时表空间。 4\. ：这是数据库服务器用于存储还原信息的还原表空间。如果数据库使用 &quot; 自动还原管理 &quot; ，那么数据库在任何指定时间必须只具有一个活动的还原表空间。此表空间是在创建数据库时创建的。 5\. ：此表空间用于存储永久用户对象和数据。在预配置数据库中， USERS 表空间是用于存储非系统用户创建的所有对象的默认表空间。对于 SYS 和 SYSTEM 用户（系统用户），默认的永久表空间依然是 SYSTEM 。 6\. ：此表空间包含创建数据库时可以安装的示例方案。这些示例方案为各种示例提供了一个通用平台。 Oracle 文档和课件中包含了建立在这些示例方案基础上的示例。 注：为简化管理，通常只对索引使用表空间。

**----------------------------------------------------------------** **使用** **sqlplus** **管理表空间：** **1.** **使用** **sqlplus** **创建表空间** CREATEDATAFILE /opt/oracle10g/oradata/oracle0/wood_tablespaces.dbf&amp;apos;~SIZE~ _100M_ ~~~~~~~~~~~~~~~~~~~~~~~ 指定数据文件大小 AUTOEXTEND~~~~~~~~~~~~ 指定数据文件自动扩展大小 NEXT~ _10M_ **~~~~~~~~~~~~~~~~~~~~~~~~~** # 指定数据文件每次扩展 10M MAXSIZE~~~~~~~~ 指定数据文容量最大值：无限制 / 或者指定大小 LOGGING~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~# 创建表空间同时生成重做日志 / 或者使用 NOLOGGING: 创建表空间时 , 不创建重做日志 . EXTENT MANAGEMENT LOCAL~~~~~~~~~~~~~~~~~~~~~~~~~~~# 指定区管理方式：本地管理 SEGMENT~~~~~~~~~~AUTO~~# 指定段的管理方式为 AUTO ； 或者使用 MANUALAUTO:~~~~~ 只能使用在本地管理的表空间中 . 使用 LOCAL 管理表空间时 , 数据块中的空闲空间增加或减少后，其新状态都会在位图中反映出来。 ~~~~~~~~~~~~~~~ 位图使 Oracle 管理空闲空间的行为更加自动化，并为管理空闲空间提供了更好的性 , 但对含有 LOB 字段的表不能自动管理 .MANUAL: 目前已不用 , 主要是为向后兼容 .

**2.** **查看表空间** select tablespace_name,status, file_name,bytes from dba_tablespaces; # 查看表空间的名称 , 状态 , 数据文件 , 大小 **3.** **修改表空间** 3.1\. 修改状态 表空间的状态属性主要有在线（ ONLINE ）、离线（ OFFLINE ）、只读（ READ ONLY ）和读写（ READ WRITE ） 4 种。 通过设置表空间的状态属性，可以对表空间的使用进行管理。 表空间数据文件属于表空间，一个表空间可有多个数据文件；数据文件有在线（ ONLINE ）、离线（ OFFLINE ）、 OFFLINE DROP 三种状态 alter tablespace~ _tablespacename_ OFFLINE;alter tablespace~ _tablespacename_ ONLINE;alter tablespace~ _tablespacename_ READ ONLY;alter tablespace _~tablespacename~_ READ WRITE;3.2\. 修改表空间数据文件的大小，添加数据文件 alter database DATAFILE &amp;apos;d:\ _tablespacename_ .dbf&amp;apos; resize 10m;~~~~~// 测试成功 alter tablespace SIMPLE add datafile &amp;apos;d:\ _tablespacename_ .dbf&amp;apos; size 5m; // 测试成功 4\. 修改表空间数据文件的自动扩展性 alter database datafile &amp;apos;d:\table.dbf&amp;apos; AUTOEXTEND ON next 5m maxsize 50m;5\. 移动表空间数据文件 1). 设置数据文件状态为离线 OFFLINE:~~~~~alter tablespace wood_tablespaces OFFLINE;2). 复制数据文件 3). 重新指定表空间路径 ~~~alter tablespace wood_tablespaces RENAME DATAFILE &amp;apos;E:\table2.dbf&amp;apos; to &amp;apos;D:\table.dbf&amp;apos;;4). 重新设置数据文件状态为离线

**4.** **删除** **tablespaces** 4.1\. 首先看一下是不是已经使用了 OMF~~~~~sql&gt; show parameter db_create_file_dest~~~~~~~~~~# 查看参数 db_create_file_dest, 如果已经设置则 :~~~~~sql&gt; drop tablespace~ _tablespacename_ ~~~~~~~~~~~~ 可以直接删除表空间， OMF 会删除相应的数据文件 4.2\. 如果没使用 OMF, 则： ~~~~~sql&gt; drop tablespace _tablespacename_ including contents and datafiles

**5.** **设置默认表空间** ~~1 ） . 查询 ( 当前用户 ) 默认表空间 select default_tablespace from user_users;~~2 ） . 修改默认表空间 alter database default tablespace _tablespacename_ ;~~~~~~~~ 如果是 oracle 9i 本语句不支持，但能让用户指向某表空间，具体做法如下： ~~~~~~~~ 例： alter user scott default tablespace users; (scott 为用户名 ,users 为表空间 )~~ 有时会出现表空间有存在的情况，这时一般都是以下几个原因造成的： ~~ 写错表空间名，我想的话这种机率较小。 ~~ 回想一下，你在创建表空间时是否给表空间表加了双引号如： ~~~~~~TABLESPACE &quot; _tablespacename_ &quot; ………………~~~~~~~~ 如果是这样的话，你在修改默认表空间，写表空间名字的时候就要区分大小了，这个是非常重要的，并且还要加上双引号， ~~~~~~~~ 如： alter user scott default tablespace &quot;Sample&quot;;(scott 为用户名 ) 。 ~~

---------------------------------------------------------------------

1 、查看表空间的名称及大小 ~~select t.tablespace_name, round(sum(bytes/(1024*1024)),0) ts_size~~from dba_tablespaces t, dba_data_files d~~where t.tablespace_name = d.tablespace_name~~group by t.tablespace_name;2 、查看表空间物理文件的名称及大小 ~~select tablespace_name, file_id, file_name,~~round(bytes/(1024*1024),0) total_space~~from dba_data_files ~~order by tablespace_name;

3 、查看表空间的使用情况 ~~select sum(bytes)/(1024*1024) as free_space,tablespace_name~~~from dba_free_space~~group by tablespace_name;

**----------------------------------------------------------------** **使用** **EM** **管理表空间** **1.** **使创建新表空间** :

**1.1.Extent Management** **（区管理）** ~~~~~-Locally Managed （本地管理表空间中的区） ~~~~~-Dictionary Managed （字典管理） **表空间中的空间管理** 在表空间中以区为单位分配空间。创建表空间后可使用以下方法之一来跟踪空闲空间和已用空间： a.~ 本地管理的表空间：在表空间中通过位图管理区。位图中的每一位对应一个块或一组块。分配区或为重新利用空间而释放区后， Oracle 服务器通过更改位图值来显示块的新状态。 - 在表空间中管理空闲区。 - 使用位图记录空闲区。 - 每一位对应于一个块或一组块。 - 位值指示空闲区或占用区。 - 建议使用本地管理的表空间。 b.~ 字典管理的表空间：由数据字典管理区。每当分配或取消分配区后， Oracle 服务器会更新数据字典中的相应表。这是为了实现向后兼容；建议使用本地管理的表空间。 - 由数据字典管理空闲区。 - 分配或取消分配区后会更新相应的表。 - 支持这些表空间仅仅是为了向后兼容。 **优缺点：** **在字典中管理** **(DICTIONARY):** 将数据文件中的每一个存储单元做为一条记录 , 所以在做 DM 操作时 , 就会产生大量的对这个管理表的 Delete 和 Update 操作 . 做大量数据管理时 , 将会产生很多的 DM 操作 , 严重的影响性能 , 同时 , 长时间对表数据的操作 , 会产生很多的磁盘碎片 , 这就是为什么要做磁盘整理的原因 . **本地管理** **(LOCAL):** 用二进制的方式管理磁盘 , 有很高的效率 , 同进能最大限度的使用磁盘 . 同时能够自动跟踪记录临近空闲空间的情况，避免进行空闲区的合并操作。 **与字典管理表空间相比，本地管理表空间具有以下优势：** 1.~ 如果使用本地管理，则不需要执行递归空间管理操作。采用字典管理表空间时，如果使用或释放区中的空间导致另一个操作使用或释放还原段或数据字典表中的空间，就会发生这种情况。 2.~ 由于采用本地管理表空间时并不记录数据字典表中的空闲空间，因此可以减少对这些表的争用。 3.~ 在本地管理区，可自动跟踪相邻的空闲空间而无需合并空闲区。 4.~ 系统会自动确定本地管理区的大小。 5.~ 对区位图进行更改不会生成还原信息，因为这些更改并不更新数据字典中的表（表空间限额信息等特殊情况除外）。 **1.2.Type** **（表空间类型）** ~~~~~~~-Permanent 用户表空间 : 用于存放用户数据表空间，可以直接写成 : CREATE TABLESPACE &quot;SAMPLE&quot;......~~~~~~-Temporary~ 临时表空间 , 用于临时数据的存放 ; 创建临时表空间的语法 :CREATE TEMPORARY TABLESPACE &quot;SAMPLE&quot;......~~~~~~~-Undo 还原表空间 . 用于存入重做日志文件 .~ 创建还原表空间的语法 :CREATE UNDO TABLESPACE &quot;SAMPLE&quot;...... **1.3.&quot;Status** **（状态）** **&quot;** - **Read Write** **（读写）：** 选择 &quot; 读写 &quot; 状态表示创建表空间后，用户可以对表空间进行读写操作。这是默认设置。 - **Read Only （只读）：** 指定 &quot; 只读 &quot; 可使表空间转换到只读模式。 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 此状态下，可以完成（提交或回退）现有的事务处理，但是，不允许对表空间中的对象进一步执行数据操纵语言 (DML) 操作。 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 表空间已联机，但处于只读状态。不能使 SYSTEM 或 SYSAUX 表空间处于只读模式。 **-Offline~~~~~~** **（脱机）：** 可以让联机的表空间脱机，使数据库的这部分暂时不可用于一般用途。 数据库的余下部分是开放的，用户可以访问其中的数据。表空间脱机时，可以使用以下选项： ~~~~~~~- Normal~~~ （正常）：如果表空间中的所有数据文件都不存在错误状态，则通过正常方式便可使表空间脱机。 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 当 Oracle 数据库使表空间脱机时，通过对表空间中的所有数据文件设置检查点，可以确保将所有数据写入磁盘。 ~~~~~~- （临时）：如果表空间中的一个或多个文件存在错误状态，也可以使表空间暂时脱机。 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 当 Oracle 数据库使（尚未脱机的）数据文件脱机时，会对这些数据文件设置检查点。 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 如果没有任何文件脱机，但是您使用了临时子句，则使表空间重新联机时便不需要执行介质恢复。 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 但是，如果因写错误而导致表空间的一个或多个文件脱机，而此时您让表空间临时脱机，那么表空间需要执行恢复后才能重新联机。 ~~~~~~- （立即）：表空间可以立即脱机， Oracle 数据库不需要对任何数据文件设置检查点。 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 如果指定了 &quot;Immediate （立即） &quot; ，则必须先对表空间执行介质恢复，才能使表空间联机。 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 如果数据库在 NOARCHIVELOG 模式下运行，则无法立即使表空间脱机。 ~~~~~~-Recover （进行恢复）： FOR RECOVER 设置已被淘汰。支持此语法的目的是为了实现向后兼容。

**2.Add Datafiles** **（添加数据文件）**

**3.Storage** **存储管理：** **3.1** **本地管理表空间中的区：** 3.1.1\. （自动）：又称为自动分配，这种方式指定表空间中的区大小由系统管理。您不能指定区大小。不能为临时表空间指定 &quot;Automatic （自动） &quot; 。 3.1.2~Uniform （统一）：这种方式指定使用指定的统一区大小管理表空间。默认大小为 1 MB 。临时表空间的所有区都是统一的，而且采用默认值。 ~~~~~~~~ 不能为还原表空间指定 &quot;Uniform （统一） &quot; **3.2.** **本地管理表空间中的段：** 3.2.1 （自动）： Oracle 数据库使用位图管理段中的空闲空间。位图描述了段中各个数据块的状态，该状态与插入行可使用的块中的空间量有关。随着数据块中可用空间的增多或减少，位图会反映数据块的新状态。通过使用位图， Oracle 数据库可以更自动地管理空闲空间，因此，这种空间管理方式被称为 &quot; 自动段空间管理 (ASSM)&quot; 。 3.2.2 Manual （手动）：此方式指定使用空闲列表来管理段中的空闲空间。空闲列表是由一些数据块组成的列表，插入行可使用这些数据块中的空间。由于这种管理段空间的方式需要为在表空间中创建的方案对象指定并优化 PCTUSED 、 FREELISTS 和 FREELIST GROUPS 存储参数，因此这种方式称为 &quot; 手动段空间管理 &quot; 。支持此方式是为了实现向后兼容；建议使用 ASSM 。 **3.3** **事件记录** 对表空间对象所做的更改会写入重做日志。如果未启用事件记录，则使用 SQL*Loader 的任何直接加载和直接加载 INSERT 操作都不会写入到重做日志中，因此如果丢失了数据，对象是不可恢复的。因此，如果在未启用事件记录的情况下创建了对象，就必须备份这些对象，以便可进行恢复。 有关事件记录子句的详细信息，请参阅《 Oracle 数据库参考手册》。 **3.4** **块信息** 这个区域显示所创建表空间使用的块大小。此处显示值为只读值。如果设置了任一其它块大小初始化参数 (DB_nK_CACHE_SIZE) ，则会在此处列出其它值作为选项。有关定义其它块大小的详细信息，请参阅《 Oracle 数据库管理员指南》。

**4.** **修改表空间** **(edit)** **：** 1\. 重命名：输入表空间的新名称 2\. 更改状态：表空间有三种不同的状态 ReadWrite,Read Only,Offline3\. 更改大小：通过向表空间添加数据文件，或者更改现有数据文件的大小 4\. 存储选项：单击 &quot;Storage （存储） &quot; 可更改表空间的事件记录行为。 5.Thresholds （阈值）：可在表空间中空间使用情况到达警告或严重级别时进行更改。共有三个选项： - Use Database Default Thresholds （使用数据库默认阈值）：使用预设的默认值，可以选择设置这些默认值。 - Specify Thresholds （指定阈值）：可以设置此特定表空间的阈值。 - Disable Thresholds （禁用阈值）：关闭这个表空间的空间使用预警。 注：注册阈值预警需要花费数分钟的时间。

**5.** **删除表空间（** **delete** **）** 如果不再需要表空间及其内容（表空间中包含的段），可将其从数据库中删除。必须具有 DROP TABLESPACE 系统权限才能删除表空间。 删除表空间时，会删除关联数据库控制文件中的文件指针。而且，如果正在使用 OMF ，则还会删除基础操作系统文件。如果没有使用 OMF ，则可以根据需要指示 Oracle 服务器删除构成已删除表空间的操作统文件（数据文件）。如果不指示 Oracle 服务器在删除表空间的同时删除数据文件，那么，如果以后要删除这些文件，则必须使用操作系统的相应命令。 不能删除包含任何活动段的表空间。例如，如果表空间中的某个表当前正在使用中，或者该表空间包含回退未提交事务处理所需要的还原数据，则不能删除该表空间。表空间的状态可以是联机也可以是脱机，但是在删除表空间之前，最好使其处于脱机状态。

**6.** **查看表空间信息** 表空间信息： - DBA_TABLESPACES- V$TABLESPACE 数据文件信息： - DBA_DATA_FILES- V$DATAFILE 临时文件信息： - DBA_TEMP_FILES- V$TEMPFILE

**7.** **查看表空间内容** **Administration &gt; Tablespaces &gt; Show Tablespace** **Contents &gt; Actions &gt; Show Tablespace Contents**

**8.** **对表空间执行的操作** **:** 1\. Add Datafile （添加数据文件）：将数据文件添加到表空间，这会增大表空间。 2.Like （类似创建）：将表空间用作模板，创建另一个表空间。 3.DDL （生成 DDL ）：生成用于创建表空间的数据定义语言 (DDL) 语句。此语句随后会复制并粘贴到文本文件中，以用作脚本或文档。 4.Locally Managed （设置为本地管理）：如果表空间当前是字典管理表空间，则可将该表空间转换为本地管理表空间。这种转换只能单向进行；不能将该表空间重新转换到字典管理表空间。 5.Readonly （只读模式）：停止对表空间的所有写操作。允许完成当前的事务处理，但是，不允许对表空间启动新 DML 活动或其它写活动。只有表空间的当前状态不是只读时，才显示此选项。 6.Writable （可写模式）：允许对表空间中的对象启动 DML 活动和其它写活动。只有表空间的当前状态不是可写时，才显示此选项。 7.Place Online （联机）：使当前脱机的表空间联机。 8\. （重组）：启动 &quot;Reorganization Wizard （重组向导） &quot; ，使用此向导可在表空间中各处移动对象以回收不可用的空间。应当在表空间中的对象使用不很是频繁的期间执行此任务。 9.Segment Advisor （运行段指导）：启动 &quot;Segment Advisor （段指导） &quot; ，使用该指导可根据对象中空间碎片的级别来确定对象是否拥有可用于执行回收的空间。在表空间级别，会针对表空间中的每个段生成建议。 10.Dependencies （显示相关性）：显示此表空间依赖的对象，或依赖于此表空间的对象。 11.Tablespace Contents （显示表空间内容）：显示关于表空间中所有段的信息，包括所有区的图形。 12.Offline （脱机）：使当前联机的表空间不可用。此时不会删除表空间，只是表空间不可用。

**扩大数据库** 可以按以下方式扩大数据库： 1.~ 创建新表空间 2.~ 将数据文件添加到现有表空间 3.~ 增加数据文件的大小 4.~ 动态扩展数据文件

表空间和数据文件 一个数据库可划分为多个逻辑存储单元，这些单元称为表空间，表空间可用于对相关逻辑结构进行分组。 一个表空间中包括一个或多个数据文件。 一个数据文件仅属于一个表空间。 一个数据库按逻辑都分为一个或多个表空间。 每个表空间显式创建一个或多个数据文件，这样可在表空间中按物理方式存储所有逻辑结构的数据。

SYSTEM 和 SYSAUX 表空间是必需存在的表空间。 这些表空间是在创建数据库时创建的。 这些表空间必须是联机的。表空间的状态可以是联机的（可访问）也可以是脱机的（不可访问）。 SYSTEM 表空间用于核心功能（例如，数据字典表）。 辅助的 SYSAUX 表空间用于附加的数据库组件 .

~-------------

[关于](http://www.cnblogs.com/jonescheng/archive/2008/05/08/1189063.html) **redo log 和** **undo log 这两个概念**

redo log~ 重做日志 undo log~ 撤消日志 重做日志：每当有操作执行前，将数据真正更改时，先前相关操作写入重做日志。这样当断电，或者一些意外，导致后续任务无法完成时，系统恢复后，可以继续完成这些更改 撤消日志：当一些更改在执行一半时，发生意外，而无法完成，则可以根据撤消日志恢复到更改之前的壮态 网上找到一些解说：以便以后自己参考 有两个概念：前滚与回退 比如某一时刻数据库 DOWN 机了，有两个事务，一个事务已经提交，另一个事务正在处理 数据库重启的时候就要根据日志进行前滚及回退，把已提交事务的更改写到数据文件，未提交事务的更改恢复到事务开始前的状态。

redo--&gt; undo--&gt;datafileinsert 一条记录时 , 表跟 undo 的信息都会放进 redo 中 , 在 commit 或之前 , redo 的信息会放进硬盘上 . 故障时 , redo 便可恢复那些已经 commit 了的数据 .

redo-&gt; 每次操作都先记录到 redo 日志中，当出现实例故障（像断电），导致数据未能更新到数据文件，则数据库重启时须 redo ，重新把数据更新到数据文件 undo-&gt; 记录更改前的一份 copy ，但你系统 rollback 时，把这份 copy 重新覆盖到原来的数据

redo-&gt; 记录所有操作，用于恢复（ redo records all the database transaction used for recovery ） undo-&gt; 记录所有的前印象，用于回滚（ undo is used to store uncommited data infor used for rollback ）

redo-&gt; 已递交的事务 , 实例恢复时要写到数据文件去的 undo-&gt; 未递交的事务 .

redo 的原因是：每次 commit 时，将数据的修改立即写到 online redo 中，但是并不一定同时将该数据的修改写到数据文件中。因为该数据已经提交，但是只存在联机日志文件中，所以在恢复时需要将数据从联机日志文件中找出来，重新应用一下，使已经更改数据在数据文件中也改过来！

undo 的原因是：在 oracle 正常运行时，为了提高效率，加入用户还没有 commit, 但是空闲内存不多时，会由 DBWR 进程将脏块写入到数据文件中，以便腾出宝贵的内存供其它进程使用。这就是需要 UNDO 的原因。因为还没有发出 commit 语句，但是 oracle 的 dbwr 进程已经将没有提交的数据写到数据文件中去了。

undo 也是也是 datafile ， 可能 dirty buffer 没有写回到磁盘里面去。 只有先 redo apply 成功了，才能保证 undo datafile 里面的东西都是正确的，然后才能 rollback

做 undo 的目的是使系统恢复到系统崩溃前 ( 关机前 ) 的状态 , 再进行 redo 是保证系统的一致性 . 不做 undo, 系统就不会知道之前的状态 ,redo 就无从谈起

所以 instance crash recovery 的时候总是先 rollforward ， 再 rollback

undo 回退段中的数据是以 &quot; 回退条目 &quot; 方式存储。 回退条目 = 块信息 ( 在事务中发生改动的块的编号 )+ 在事务提交前存储在块中的数据

在每一个回退段中 oracle 都为其维护一张 &quot; 事务表 &quot; 在事务表中记录着与该回退段中所有回退条目相关的事务编号（事务 SCN&amp; 回退条目）

redo 重做记录由一组 &quot; 变更向量 &quot; 组成。 每个变更变量中记录了事务对数据库中某个块所做的修改。 当用户提交一条 commit 语句时， LGWR 进程会立刻将一条提交记录写入到重做日志文件中，然后再开始写入与该事务相关的重做信息。

# 事务提交成功后， Oracle 将为该事备生成一个系统变更码（ SCN ）。事务的 SCN 将同时记录在它的提交记录和重做记录中。

commit 提交事务前完成的工作： · 在 SGA 区的回退缓存中生成该事务的回退条目。在回退条目中保存有该事务所修改的数据的原始版本。 · 在 SGA 区的重做日志缓存中生成该事务的重做记录。重做记录中记载了该事务对数据块所进行的修改，并且还记载了对回退段中的数据块所进行的修改。缓存中的重做记录有可能在事务提交之前就写入硬盘中。 · 在 SGA 区的数据库缓丰中记录了事务对数据库所进行的修改。这些修改也有可能在事务提交之前就写入硬盘中。

提交事务时完成的工作： · 在为该事务指定的回退段中的内部事务表内记录下这个事务已经被提交，并且生成一个惟一的 SCN 记录在内部事务表中，用于惟一标识这个事务。 ·LGWR 后进进程将 SGA 区重做日志缓存中的重做记录写入联机重做日志文件。在写入重做日志的同时还将写入该事务的 SCN 。 ·Oracle 服务进程释放事务所使用的所有记录锁与表锁。 ·Oracle 通知用户事务提交完成。 ·Oracle 将该事务标记为已完成。

rollback 回退事务完成的工作： ·Oracle 通过使用回退段中的回退条目，撤销事务中所有 SQL 语句对数据库所做的修改。 ·Oracle 服务进程释放事务所使用的所有锁 ·Oracle 通知事务回退成功。 ·Oracle 将该事务标记为已完成

举个例子： insert into a(id) values(1);(redo) 这条记录是需要回滚的。 回滚的语句是 delete from a where id = 1;(undo)

试想想看。如果没有做 insert into a(id) values(1);(redo) 那么 delete from a where id = 1;(undo) 这句话就没有意义了。

现在看下正确的恢复 : 先 insert into a(id) values(1);(redo) 然后 delete from a where id = 1;(undo) 系统就回到了原先的状态，没有这条记录了。

--------------------

~ 在这里会介绍 UNDO ， REDO 是如何产生的，对 TRANSACTIONS 的影响，以及他们之间如何协同工作的。 什么是 REDO~~~~~REDO 记录 transaction logs ，分为 online 和 archived 。以恢复为目的。 ~~~~~ 比如，机器停电，那么在重起之后需要 online redo logs 去恢复系统到失败点。 ~~~~~ 比如，磁盘坏了，需要用 archived redo logs 和 online redo logs 区恢复数据。 ~~~~~ 比如， truncate 一个表或其他的操作，想恢复到之前的状态，同样也需要。 什么是 UNDO~~~~~REDO 是为了重新实现你的操作，而 UNDO 相反，是为了撤销你做的操作，比如你得一个 TRANSACTION 执行失败了或你自己后悔了，则需要用 ROLLBACK 命令回退到操作之前。回滚是在逻辑层面实现而不是物理层面，因为在一个多用户系统中，数据结构， blocks 等都在时时变化，比如我们 INSERT 一个数据，表的空间不够，扩展了一个新的 EXTENT ，我们的数据保存在这新的 EXTENT 里，其它用户随后也在这 EXTENT 里插入了数据，而此时我想 ROLLBACK ，那么显然物理上讲这 EXTENT 撤销是不可能的，因为这么做会影响其他用户的操作。所以， ROLLBACK 是逻辑上回滚，比如对 INSERT 来说，那么 ROLLBACK 就是 DELETE 了。 COMMIT~~~~~ 以前，常想当然地认为，一个大的 TRANSACTION （比如大批量地 INSERT 数据）的 COMMIT 会花费时间比短的 TRANSACTION 长。而事实上是没有什么区别的，因为 ORACLE 在 COMMIT 之前已经把该写的东西写到 DISK 中了，我们 COMMIT 只是 1 ，产生一个 SCN 给我们 TRANSACTION ， SCN 简单理解就是给 TRANSACTION 排队，以便恢复和保持一致性。 2 ， REDO 写 REDO 到 DISK 中（ LGWR ，这就是 log file sync ），记录 SCN 在 ONLINE REDO LOG ，当这一步发生时，我们可以说事实上已经提交了，这个 TRANSACTION 已经结束（在 V$TRANSACTION 里消失了） 3 ， SESSION 所拥有的 LOCK （ V$LOCK ）被释放。 4 ， Block Cleanout （这个问题是产生 ORA-01555: snapshot too old 的根本原因） ROLLBACK~~~~~ROLLBACK 和 COMMIT 正好相反， ROLLBACK 的时间和 TRANSACTION 的大小有直接关系。因为 ROLLBACK 必须物理上恢复数据。 COMMIT 之所以快，是因为 ORACLE 在 COMMIT 之前已经作了很多工作（产生 UNDO ，修改 BLOCK ， REDO ， LATCH 分配）， ROLLBACK 慢也是基于相同的原因。 ~~~~~ROLLBACK 会 ~~~~~1 ，恢复数据， DELETE 的就重新 INSERT ， INSERT 的就重新 DELETE ， UPDATE 的就再 UPDATE 。 ~~~~~2 ， RELEASE LOCK~~~~~~ROLLBACK 要比 COMMIT 消耗更多资源，因为 ORACLE 认为你一旦做数据更新，那么就意味着你要 COMMIT （其他数据库不全是这种设计理念，比如 DB2 ），所以在你更新数据的时候就做了大量的工作，这也可以理解为什么不建议用 TABLE 来做 TEMPORARY TABLE 。（ TEMP TABLE 消耗的 REDO 比固定表在 INSERT 时要少很多 ~~~~ ， UPDATE 时差不多是 1/2 ，但是 DELETE 却相差无几）

OMF

**Oracle Managed Files (OMF)** 如果使用 Oracle Managed Files (OMF) ，则不需要直接管理构成 Oracle 数据库的操作系统文件。可以根据数据库对象而不是文件名指定操作。对于以下数据库结构，可以按需要在数据库内部使用标准文件系统接口来创建和删除文件： 1.~ 表空间 2.~ 重做日志文件 3.~ 控制文件 4.~ 归档日志 5.~ 块更改跟踪文件 7.~ 闪回日志 8\. 备份 数据库可以混合包含 Oracle Managed Files 和非 Oracle Managed Files 。由上面任一参数指定的文件系统目录必须已经存在：数据库不会创建文件系统目录。该目录还必须拥有允许数据库在其中创建文件的权限。

**参数说明** **:** DB_CREATE_FILE_DEST~~~~~~~~~~~~~~~~~~~~~ 定义数据文件和临时文件的默认文件系统目录的位置 DB_CREATE_ONLINE_LOG_DEST_n~~~ 定义重做日志文件和控制文件的创建位置 DB_RECOVERY_FILE_DEST~~~~~~~~~~~~~~~ 定义 RMAN 备份位置 示例： SQL&gt; ALTER SYSTEM SET DB_CREATE_FILE_DEST = &amp;apos;/u01/oradata&amp;apos;;SQL&gt; CREATE TABLESPACE tbs_1;

ASM

Automatic Storage Management

ASM ：概念 使用 ASM 并不意味着不再需要任何预先存在的数据库功能。现有数据库可以按原有方式 运行。可以将新文件创建为 ASM 文件，并按原有方式管理现有文件，也可以最后将这些 文件移植到 ASM 。 上图描述了使用 ASM 的 Oracle 数据库中不同存储组件之间的关系。图的左侧和中间部分 显示了以前版本中存在的关系。图右侧为 ASM 引入的新概念。 数据库文件可作为 ASM 文件进行存储。新层次的顶端为 ASM 磁盘组。任何单个 ASM 文件只能包含在一个磁盘组中。但是，一个磁盘组可能包含属于多个数据库的文件，一个 数据库可能使用多个磁盘组中的存储空间。如图所示，一个磁盘组由多个 ASM 磁盘构成， 而每个 ASM 磁盘只属于一个磁盘组。 ASM 文件始终分布在磁盘组中的所有 ASM 磁盘上。 ASM 磁盘按分配单位 (AU) 进行分区，每个分配单位为一兆字节。分配单位是 ASM 分配 的最小连续磁盘空间。 ASM 不允许在多个分配单位之间分割一个 Oracle 块。 注：此图只涉及了一类 ASM 文件：数据文件。实际上， ASM 还可用来存储其它数据库 文件类型。

ASM ：主要功能和优点 ASM 将文件划分为区（不同于前面介绍的数据文件区），而且将每个文件的区均匀地分 布在所有磁盘上。 ASM 使用索引技术跟踪每个区的位置。存储容量发生变化时， ASM 并 不重新条带化所有数据，而是根据添加或删除的存储量，按比例移动一定数量的数据，通 过重新平均分配文件来保持磁盘间的负载平衡。此操作是在数据库处于活动状态时完成的。 可以提高重新平衡操作的速度以更快地完成操作，也可以降低此速度以减少对 I/O 子系统 的影响。 ASM 还提供了镜像保护，因此不需要购买第三方逻辑卷管理器。 ASM 的一个特 有优势是可为每个文件创建镜像，而不是为每个卷创建镜像。因此，同一磁盘组可以包含 镜像文件或非镜像文件的组合。 ASM 支持数据文件、日志文件、控制文件、归档日志、 Recovery Manager (RMAN) 备份 集及其它 Oracle 数据库文件类型。 ASM 还支持 RAC ，这样就不再需要使用集群逻辑卷 管理器或集群文件系统。

ASM ： 1\. 对文件而不是逻辑卷进行条带化 2.~ 提供联机重新配置磁盘和动态重新平衡功能 3.~ 可用来调整重新平衡速度 4.~ 为每个文件提供冗余 5\. 仅支持 Oracle 数据库文件 6.~ 可识别集群 7.~ 可自动安装